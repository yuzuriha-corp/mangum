{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mangum Mangum is an adapter for using ASGI applications with AWS Lambda & API Gateway. It is intended to provide an easy-to-use, configurable wrapper for any ASGI application deployed in an AWS Lambda function to handle API Gateway requests and responses. Documentation : https://mangum.io/ Features API Gateway support for HTTP and REST APIs. Compatibility with ASGI application frameworks, such as Starlette , FastAPI , and Quart . Support for binary media types and payload compression in API Gateway using GZip or Brotli. Works with existing deployment and configuration tools, including Serverless Framework and AWS SAM . Startup and shutdown lifespan events. Requirements Python 3.6+ Installation pip install mangum Example from mangum import Mangum async def app ( scope , receive , send ): await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/plain; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : b \"Hello, world!\" }) handler = Mangum ( app ) Or using a framework. from fastapi import FastAPI from mangum import Mangum app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app )","title":"Introduction"},{"location":"#mangum","text":"Mangum is an adapter for using ASGI applications with AWS Lambda & API Gateway. It is intended to provide an easy-to-use, configurable wrapper for any ASGI application deployed in an AWS Lambda function to handle API Gateway requests and responses. Documentation : https://mangum.io/","title":"Mangum"},{"location":"#features","text":"API Gateway support for HTTP and REST APIs. Compatibility with ASGI application frameworks, such as Starlette , FastAPI , and Quart . Support for binary media types and payload compression in API Gateway using GZip or Brotli. Works with existing deployment and configuration tools, including Serverless Framework and AWS SAM . Startup and shutdown lifespan events.","title":"Features"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"pip install mangum","title":"Installation"},{"location":"#example","text":"from mangum import Mangum async def app ( scope , receive , send ): await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/plain; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : b \"Hello, world!\" }) handler = Mangum ( app ) Or using a framework. from fastapi import FastAPI from mangum import Mangum app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app )","title":"Example"},{"location":"adapter/","text":"Adapter The heart of Mangum is the adapter class. It is a configurable wrapper that allows any ASGI application (or framework) to run in an AWS Lambda deployment. The adapter accepts a number of keyword arguments to configure settings related to logging, HTTP & lifespan behaviour, and API Gateway events. handler = Mangum ( app , lifespan = \"auto\" , log_level = \"info\" , api_gateway_base_path = None , text_mime_types = None , dsn = None , api_gateway_endpoint_url = None , api_gateway_region_name = None ) All arguments are optional, but some may be necessary for specific use-cases (e.g. dsn is only required for WebSocket support). Configuring an adapter instance class mangum.adapter. Mangum ( app , lifespan='auto' , log_level='info' , api_gateway_base_path=None , text_mime_types=None , enable_lifespan=True ) Creates an adapter instance. app - An asynchronous callable that conforms to version 3.0 of the ASGI specification. This will usually be an ASGI framework application instance. lifespan - A string to configure lifespan support. Choices are auto , on , and off . Default is auto . log_level - A string to configure the log level. Choices are: info , critical , error , warning , and debug . Default is info . api_gateway_base_path - Base path to strip from URL when using a custom domain name. text_mime_types - A list of MIME types to include with the defaults that should not return a binary response in API Gateway. Creating an AWS Lambda handler The adapter can be used to wrap any application without referencing the underlying methods. It defines a __call__ method that allows the class instance to be used as an AWS Lambda event handler function. from mangum import Mangum from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app ) However, this is just one convention, you may also intercept events and construct the adapter instance separately. This may be useful if you need to implement custom event handling. The handler in the example above could be replaced with a function. def handler ( event , context ): if event . get ( \"some-key\" ): # Do something or return, etc. return asgi_handler = Mangum ( app ) response = asgi_handler ( event , context ) # Call the instance with the event arguments return response Retrieving the AWS event and context The AWS Lambda handler event and context arguments are made available to an ASGI application in the ASGI connection scope. scope [ 'aws.event' ] scope [ 'aws.context' ] If you're using FastAPI it can be retrieved from the scope attribute of the request object. from fastapi import FastAPI from mangum import Mangum from starlette.requests import Request app = FastAPI () @app . get ( \"/\" ) def hello ( request : Request ): return { \"aws_event\" : request . scope [ \"aws.event\" ]} handler = Mangum ( app )","title":"Adapter"},{"location":"adapter/#adapter","text":"The heart of Mangum is the adapter class. It is a configurable wrapper that allows any ASGI application (or framework) to run in an AWS Lambda deployment. The adapter accepts a number of keyword arguments to configure settings related to logging, HTTP & lifespan behaviour, and API Gateway events. handler = Mangum ( app , lifespan = \"auto\" , log_level = \"info\" , api_gateway_base_path = None , text_mime_types = None , dsn = None , api_gateway_endpoint_url = None , api_gateway_region_name = None ) All arguments are optional, but some may be necessary for specific use-cases (e.g. dsn is only required for WebSocket support).","title":"Adapter"},{"location":"adapter/#configuring-an-adapter-instance","text":"class mangum.adapter. Mangum ( app , lifespan='auto' , log_level='info' , api_gateway_base_path=None , text_mime_types=None , enable_lifespan=True ) Creates an adapter instance. app - An asynchronous callable that conforms to version 3.0 of the ASGI specification. This will usually be an ASGI framework application instance. lifespan - A string to configure lifespan support. Choices are auto , on , and off . Default is auto . log_level - A string to configure the log level. Choices are: info , critical , error , warning , and debug . Default is info . api_gateway_base_path - Base path to strip from URL when using a custom domain name. text_mime_types - A list of MIME types to include with the defaults that should not return a binary response in API Gateway.","title":"Configuring an adapter instance"},{"location":"adapter/#creating-an-aws-lambda-handler","text":"The adapter can be used to wrap any application without referencing the underlying methods. It defines a __call__ method that allows the class instance to be used as an AWS Lambda event handler function. from mangum import Mangum from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app ) However, this is just one convention, you may also intercept events and construct the adapter instance separately. This may be useful if you need to implement custom event handling. The handler in the example above could be replaced with a function. def handler ( event , context ): if event . get ( \"some-key\" ): # Do something or return, etc. return asgi_handler = Mangum ( app ) response = asgi_handler ( event , context ) # Call the instance with the event arguments return response","title":"Creating an AWS Lambda handler"},{"location":"adapter/#retrieving-the-aws-event-and-context","text":"The AWS Lambda handler event and context arguments are made available to an ASGI application in the ASGI connection scope. scope [ 'aws.event' ] scope [ 'aws.context' ] If you're using FastAPI it can be retrieved from the scope attribute of the request object. from fastapi import FastAPI from mangum import Mangum from starlette.requests import Request app = FastAPI () @app . get ( \"/\" ) def hello ( request : Request ): return { \"aws_event\" : request . scope [ \"aws.event\" ]} handler = Mangum ( app )","title":"Retrieving the AWS event and context"},{"location":"asgi-frameworks/","text":"Frameworks Mangum is intended to provide support to any ASGI ( Asynchronous Server Gateway Interface ) application or framework. The \"turtles all the way down\" principle of ASGI allows for a great deal of interoperability across many different implementations, so the adapter should \"just work\"* for any ASGI application or framework. * if it doesn't, then please open an issue . :) Background We can think about the ASGI framework support without referencing an existing implementation. There are no framework-specific rules or dependencies in the adapter class, and all applications will be treated the same. Let's invent an API for a non-existent microframework to demonstrate things further. This could represent any ASGI framework application: import framework from mangum import Mangum app = framework . applications . Application () @app . route ( \"/\" ) def endpoint ( request : framework . requests . Request ) -> dict : return { \"hi\" : \"there\" } handler = Mangum ( app ) None of the framework details are important here. The routing decorator, request parameter, and return value of the endpoint method could be anything. The app instance will be a valid app parameter for Mangum so long as the framework exposes an ASGI-compatible interface: class Application ( Protocol ): async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : ... Limitations An application or framework may implement behaviour that is incompatible with the limitations of AWS Lambda, and there may be additional configuration required depending on a particular deployment circumstance. In some cases it is possible to work around these limitations, but these kinds of limitations should generally be dealt with outside of Mangum itself. Frameworks The examples on this page attempt to demonstrate a basic implementation of a particular framework (usually from official documentation) to highlight the interaction with Mangum. Specific deployment tooling, infrastructure, external dependencies, etc. are not taken into account. Starlette Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. Mangum uses it as a toolkit in tests. It is developed by Encode , a wonderful community and collection of projects that are forming the foundations of the Python async web ecosystem. Define an application: from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from mangum import Mangum async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) routes = [ Route ( \"/\" , endpoint = homepage ) ] app = Starlette ( debug = True , routes = routes ) Then wrap it using Mangum: handler = Mangum ( app ) FastAPI FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints. from fastapi import FastAPI from mangum import Mangum app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app ) Responder Responder is a familiar HTTP Service Framework for Python, powered by Starlette. The static_dir and templates_dir parameters must be set to none to disable Responder's automatic directory creation behaviour because AWS Lambda is a read-only file system - see the limitations section for more details. from mangum import Mangum import responder app = responder . API ( static_dir = None , templates_dir = None ) @app . route ( \"/ {greeting} \" ) async def greet_world ( req , resp , * , greeting ): resp . text = f \" { greeting } , world!\" handler = Mangum ( app ) The adapter usage for both FastAPI and Responder is the same as Starlette. However, this may be expected because they are built on Starlette - what about other frameworks? Quart Quart is a Python ASGI web microframework. It is intended to provide the easiest way to use asyncio functionality in a web context, especially with existing Flask apps. This is possible as the Quart API is a superset of the Flask API. from quart import Quart from mangum import Mangum app = Quart ( __name__ ) @app . route ( \"/hello\" ) async def hello (): return \"hello world!\" handler = Mangum ( app ) Sanic Sanic is a Python 3.6+ web server and web framework that's written to go fast. It allows the usage of the async/await syntax added in Python 3.5, which makes your code non-blocking and speedy. from sanic import Sanic from sanic.response import json from mangum import Mangum app = Sanic () @app . route ( \"/\" ) async def test ( request ): return json ({ \"hello\" : \"world\" }) handler = Mangum ( app ) Django Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. It started introducing ASGI support in version 3.0 . Certain async capabilities are not yet implemented and planned for future releases, however it can still be used with Mangum and other ASGI applications at the outer application level. # asgi.py import os from mangum import Mangum from django.core.asgi import get_asgi_application os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"app.settings\" ) application = get_asgi_application () handler = Mangum ( application , lifespan = \"off\" ) This example looks a bit different than the others because it is based on Django's standard project configuration, but the ASGI behaviour is the same. Channels Channels is a project that takes Django and extends its abilities beyond HTTP - to handle WebSockets, chat protocols, IoT protocols, and more. It is the original driving force behind the ASGI specification. It currently does not support ASGI version 3, but you can convert the application from ASGI version 2 using the guarantee_single_callable method provided in asgiref . # asgi.py import os import django from channels.routing import get_default_application from asgiref.compatibility import guarantee_single_callable from mangum import Mangum os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"project.settings\" ) django . setup () application = get_default_application () wrapped_application = guarantee_single_callable ( application ) handler = Mangum ( wrapped_application , lifespan = \"off\" )","title":"ASGI Frameworks"},{"location":"asgi-frameworks/#frameworks","text":"Mangum is intended to provide support to any ASGI ( Asynchronous Server Gateway Interface ) application or framework. The \"turtles all the way down\" principle of ASGI allows for a great deal of interoperability across many different implementations, so the adapter should \"just work\"* for any ASGI application or framework. * if it doesn't, then please open an issue . :)","title":"Frameworks"},{"location":"asgi-frameworks/#background","text":"We can think about the ASGI framework support without referencing an existing implementation. There are no framework-specific rules or dependencies in the adapter class, and all applications will be treated the same. Let's invent an API for a non-existent microframework to demonstrate things further. This could represent any ASGI framework application: import framework from mangum import Mangum app = framework . applications . Application () @app . route ( \"/\" ) def endpoint ( request : framework . requests . Request ) -> dict : return { \"hi\" : \"there\" } handler = Mangum ( app ) None of the framework details are important here. The routing decorator, request parameter, and return value of the endpoint method could be anything. The app instance will be a valid app parameter for Mangum so long as the framework exposes an ASGI-compatible interface: class Application ( Protocol ): async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : ...","title":"Background"},{"location":"asgi-frameworks/#limitations","text":"An application or framework may implement behaviour that is incompatible with the limitations of AWS Lambda, and there may be additional configuration required depending on a particular deployment circumstance. In some cases it is possible to work around these limitations, but these kinds of limitations should generally be dealt with outside of Mangum itself.","title":"Limitations"},{"location":"asgi-frameworks/#frameworks_1","text":"The examples on this page attempt to demonstrate a basic implementation of a particular framework (usually from official documentation) to highlight the interaction with Mangum. Specific deployment tooling, infrastructure, external dependencies, etc. are not taken into account.","title":"Frameworks"},{"location":"asgi-frameworks/#starlette","text":"Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. Mangum uses it as a toolkit in tests. It is developed by Encode , a wonderful community and collection of projects that are forming the foundations of the Python async web ecosystem. Define an application: from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from mangum import Mangum async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) routes = [ Route ( \"/\" , endpoint = homepage ) ] app = Starlette ( debug = True , routes = routes ) Then wrap it using Mangum: handler = Mangum ( app )","title":"Starlette"},{"location":"asgi-frameworks/#fastapi","text":"FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints. from fastapi import FastAPI from mangum import Mangum app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app )","title":"FastAPI"},{"location":"asgi-frameworks/#responder","text":"Responder is a familiar HTTP Service Framework for Python, powered by Starlette. The static_dir and templates_dir parameters must be set to none to disable Responder's automatic directory creation behaviour because AWS Lambda is a read-only file system - see the limitations section for more details. from mangum import Mangum import responder app = responder . API ( static_dir = None , templates_dir = None ) @app . route ( \"/ {greeting} \" ) async def greet_world ( req , resp , * , greeting ): resp . text = f \" { greeting } , world!\" handler = Mangum ( app ) The adapter usage for both FastAPI and Responder is the same as Starlette. However, this may be expected because they are built on Starlette - what about other frameworks?","title":"Responder"},{"location":"asgi-frameworks/#quart","text":"Quart is a Python ASGI web microframework. It is intended to provide the easiest way to use asyncio functionality in a web context, especially with existing Flask apps. This is possible as the Quart API is a superset of the Flask API. from quart import Quart from mangum import Mangum app = Quart ( __name__ ) @app . route ( \"/hello\" ) async def hello (): return \"hello world!\" handler = Mangum ( app )","title":"Quart"},{"location":"asgi-frameworks/#sanic","text":"Sanic is a Python 3.6+ web server and web framework that's written to go fast. It allows the usage of the async/await syntax added in Python 3.5, which makes your code non-blocking and speedy. from sanic import Sanic from sanic.response import json from mangum import Mangum app = Sanic () @app . route ( \"/\" ) async def test ( request ): return json ({ \"hello\" : \"world\" }) handler = Mangum ( app )","title":"Sanic"},{"location":"asgi-frameworks/#django","text":"Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. It started introducing ASGI support in version 3.0 . Certain async capabilities are not yet implemented and planned for future releases, however it can still be used with Mangum and other ASGI applications at the outer application level. # asgi.py import os from mangum import Mangum from django.core.asgi import get_asgi_application os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"app.settings\" ) application = get_asgi_application () handler = Mangum ( application , lifespan = \"off\" ) This example looks a bit different than the others because it is based on Django's standard project configuration, but the ASGI behaviour is the same.","title":"Django"},{"location":"asgi-frameworks/#channels","text":"Channels is a project that takes Django and extends its abilities beyond HTTP - to handle WebSockets, chat protocols, IoT protocols, and more. It is the original driving force behind the ASGI specification. It currently does not support ASGI version 3, but you can convert the application from ASGI version 2 using the guarantee_single_callable method provided in asgiref . # asgi.py import os import django from channels.routing import get_default_application from asgiref.compatibility import guarantee_single_callable from mangum import Mangum os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"project.settings\" ) django . setup () application = get_default_application () wrapped_application = guarantee_single_callable ( application ) handler = Mangum ( wrapped_application , lifespan = \"off\" )","title":"Channels"},{"location":"external-links/","text":"External Links External links related to using Mangum. If you're interested in contributing to this page, please reference this issue in a PR.","title":"External Links"},{"location":"external-links/#external-links","text":"External links related to using Mangum. If you're interested in contributing to this page, please reference this issue in a PR.","title":"External Links"},{"location":"http/","text":"HTTP Mangum provides support for both REST and the newer HTTP APIs in API Gateway. It also includes configurable binary response support. from fastapi import FastAPI from fastapi.middleware.gzip import GZipMiddleware from mangum import Mangum app = FastAPI () app . add_middleware ( GZipMiddleware , minimum_size = 1000 ) @app . get ( \"/\" ) async def main (): return \"somebigcontent\" handler = Mangum ( app , TEXT_MIME_TYPES = [ \"application/vnd.some.type\" ]) Configuring binary responses Binary responses are determined using the Content-Type and Content-Encoding headers from the event request and a list of text MIME types. Text MIME types By default, all response data will be base64 encoded and include isBase64Encoded=True in the response except the default text MIME types and any MIME types included in the TEXT_MIME_TYPES list setting. The following types are excluded from binary responses by default: application/json application/javascript application/xml application/vnd.api+json Additionally, any Content-Type header prefixed with text/ is automatically excluded. GZip If the Content-Encoding header is set to gzip , then a binary response will be returned regardless of MIME type. State machine The HTTPCycle is used by the adapter to communicate message events between the application and AWS. It is a state machine that handles the entire ASGI request and response cycle. HTTPCycle class mangum.protocols.http. HTTPCycle ( scope , body , text_mime_types , state= , response= ) Manages the application cycle for an ASGI http connection. scope - A dictionary containing the connection scope used to run the ASGI application instance. body - A byte string containing the body content of the request. text_mime_types - A list of mime types of MIME types that should not return a binary response in API Gateway. state - An enumerated HTTPCycleState type that indicates the state of the ASGI connection. app_queue - An asyncio queue (FIFO) containing messages to be received by the application. response - A dictionary containing the response data to return in AWS Lambda. run ( self , app ) Calls the application with the http connection scope. receive ( self ) Awaited by the application to receive ASGI http events. send ( self , message ) Awaited by the application to send ASGI http events. HTTPCycleState class mangum.protocols.http. HTTPCycleState ( value , names=None , * , module=None , qualname=None , type=None , start=1 ) The state of the ASGI http connection. REQUEST - Initial state. The ASGI application instance will be run with the connection scope containing the http type. RESPONSE - The http.response.start event has been sent by the application. The next expected message is the http.response.body event, containing the body content. An application may pass the more_body argument to send content in chunks, however content will always be returned in a single response, never streamed. COMPLETE - The body content from the ASGI application has been completely read. A disconnect event will be sent to the application, and the response will be returned.","title":"HTTP"},{"location":"http/#http","text":"Mangum provides support for both REST and the newer HTTP APIs in API Gateway. It also includes configurable binary response support. from fastapi import FastAPI from fastapi.middleware.gzip import GZipMiddleware from mangum import Mangum app = FastAPI () app . add_middleware ( GZipMiddleware , minimum_size = 1000 ) @app . get ( \"/\" ) async def main (): return \"somebigcontent\" handler = Mangum ( app , TEXT_MIME_TYPES = [ \"application/vnd.some.type\" ])","title":"HTTP"},{"location":"http/#configuring-binary-responses","text":"Binary responses are determined using the Content-Type and Content-Encoding headers from the event request and a list of text MIME types.","title":"Configuring binary responses"},{"location":"http/#text-mime-types","text":"By default, all response data will be base64 encoded and include isBase64Encoded=True in the response except the default text MIME types and any MIME types included in the TEXT_MIME_TYPES list setting. The following types are excluded from binary responses by default: application/json application/javascript application/xml application/vnd.api+json Additionally, any Content-Type header prefixed with text/ is automatically excluded.","title":"Text MIME types"},{"location":"http/#gzip","text":"If the Content-Encoding header is set to gzip , then a binary response will be returned regardless of MIME type.","title":"GZip"},{"location":"http/#state-machine","text":"The HTTPCycle is used by the adapter to communicate message events between the application and AWS. It is a state machine that handles the entire ASGI request and response cycle.","title":"State machine"},{"location":"http/#httpcycle","text":"class mangum.protocols.http. HTTPCycle ( scope , body , text_mime_types , state= , response= ) Manages the application cycle for an ASGI http connection. scope - A dictionary containing the connection scope used to run the ASGI application instance. body - A byte string containing the body content of the request. text_mime_types - A list of mime types of MIME types that should not return a binary response in API Gateway. state - An enumerated HTTPCycleState type that indicates the state of the ASGI connection. app_queue - An asyncio queue (FIFO) containing messages to be received by the application. response - A dictionary containing the response data to return in AWS Lambda. run ( self , app ) Calls the application with the http connection scope. receive ( self ) Awaited by the application to receive ASGI http events. send ( self , message ) Awaited by the application to send ASGI http events.","title":"HTTPCycle"},{"location":"http/#httpcyclestate","text":"class mangum.protocols.http. HTTPCycleState ( value , names=None , * , module=None , qualname=None , type=None , start=1 ) The state of the ASGI http connection. REQUEST - Initial state. The ASGI application instance will be run with the connection scope containing the http type. RESPONSE - The http.response.start event has been sent by the application. The next expected message is the http.response.body event, containing the body content. An application may pass the more_body argument to send content in chunks, however content will always be returned in a single response, never streamed. COMPLETE - The body content from the ASGI application has been completely read. A disconnect event will be sent to the application, and the response will be returned.","title":"HTTPCycleState"},{"location":"lifespan/","text":"Lifespan Mangum supports the ASGI Lifespan protocol. This allows applications to define lifespan startup and shutdown event handlers. from mangum import Mangum from fastapi import FastAPI app = FastAPI () @app . on_event ( \"startup\" ) async def startup_event (): pass @app . on_event ( \"shutdown\" ) async def shutdown_event (): pass @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } handler = Mangum ( app , lifespan = \"auto\" ) Configuring Lifespan events Lifespan support is automatically determined unless explicitly turned on or off. A string value option is used to configure lifespan support, the choices are auto , on , and off . Options auto Application support for lifespan is inferred using the state transitions. Any error that occurs during startup will be logged and the ASGI application cycle will continue unless a lifespan.startup.failed event is sent. on Application support for lifespan is explicit . Any error that occurs during startup will be raised and a 500 response will be returned. off Application support for lifespan is ignored . The application will not enter the lifespan cycle context. Defaults to auto . State machine The LifespanCycle is a state machine that handles ASGI lifespan events intended to run before and after HTTP and WebSocket requests are handled. LifespanCycle class mangum.protocols.lifespan. LifespanCycle ( app , lifespan , state= , exception=None ) Manages the application cycle for an ASGI lifespan connection. app - An asynchronous callable that conforms to version 3.0 of the ASGI specification. This will usually be an ASGI framework application instance. lifespan - A string to configure lifespan support. Choices are auto , on , and off . Default is auto . state - An enumerated LifespanCycleState type that indicates the state of the ASGI connection. exception - An exception raised while handling the ASGI event. app_queue - An asyncio queue (FIFO) containing messages to be received by the application. startup_event - An asyncio event object used to control the application startup flow. shutdown_event - An asyncio event object used to control the application shutdown flow. exception - An exception raised while handling the ASGI event. This may or may not be raised depending on the state. run ( self ) Calls the application with the lifespan connection scope. receive ( self ) Awaited by the application to receive ASGI lifespan events. send ( self , message ) Awaited by the application to send ASGI lifespan events. startup ( self ) Pushes the lifespan startup event to application queue and handles errors. shutdown ( self ) Pushes the lifespan shutdown event to application queue and handles errors. Context manager Unlike the HTTPCycle and WebSocketCycle classes, the LifespanCycle is also used as a context manager in the adapter class. If lifespan support is turned off, then the application never enters the lifespan cycle context. with ExitStack () as stack : # Ignore lifespan events entirely if the `lifespan` setting is `off`. if self . lifespan in ( \"auto\" , \"on\" ): asgi_cycle : typing . ContextManager = LifespanCycle ( self . app , self . lifespan ) stack . enter_context ( asgi_cycle ) The magic methods __enter__ and __exit__ handle running the async tasks that perform startup and shutdown functions. def __enter__ ( self ) -> None : \"\"\" Runs the event loop for application startup. \"\"\" self . loop . create_task ( self . run ()) self . loop . run_until_complete ( self . startup ()) def __exit__ ( self , exc_type : typing . Optional [ typing . Type [ BaseException ]], exc_value : typing . Optional [ BaseException ], traceback : typing . Optional [ types . TracebackType ], ) -> None : \"\"\" Runs the event loop for application shutdown. \"\"\" self . loop . run_until_complete ( self . shutdown ()) LifespanCycleState class mangum.protocols.lifespan. LifespanCycleState ( value , names=None , * , module=None , qualname=None , type=None , start=1 ) The state of the ASGI lifespan connection. CONNECTING - Initial state. The ASGI application instance will be run with the connection scope containing the lifespan type. STARTUP - The lifespan startup event has been pushed to the queue to be received by the application. SHUTDOWN - The lifespan shutdown event has been pushed to the queue to be received by the application. FAILED - A lifespan failure has been detected, and the connection will be closed with an error. UNSUPPORTED - An application attempted to send a message before receiving the lifepan startup event. If the lifespan argument is \"on\", then the connection will be closed with an error.","title":"Lifespan"},{"location":"lifespan/#lifespan","text":"Mangum supports the ASGI Lifespan protocol. This allows applications to define lifespan startup and shutdown event handlers. from mangum import Mangum from fastapi import FastAPI app = FastAPI () @app . on_event ( \"startup\" ) async def startup_event (): pass @app . on_event ( \"shutdown\" ) async def shutdown_event (): pass @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } handler = Mangum ( app , lifespan = \"auto\" )","title":"Lifespan"},{"location":"lifespan/#configuring-lifespan-events","text":"Lifespan support is automatically determined unless explicitly turned on or off. A string value option is used to configure lifespan support, the choices are auto , on , and off .","title":"Configuring Lifespan events"},{"location":"lifespan/#options","text":"auto Application support for lifespan is inferred using the state transitions. Any error that occurs during startup will be logged and the ASGI application cycle will continue unless a lifespan.startup.failed event is sent. on Application support for lifespan is explicit . Any error that occurs during startup will be raised and a 500 response will be returned. off Application support for lifespan is ignored . The application will not enter the lifespan cycle context. Defaults to auto .","title":"Options"},{"location":"lifespan/#state-machine","text":"The LifespanCycle is a state machine that handles ASGI lifespan events intended to run before and after HTTP and WebSocket requests are handled.","title":"State machine"},{"location":"lifespan/#lifespancycle","text":"class mangum.protocols.lifespan. LifespanCycle ( app , lifespan , state= , exception=None ) Manages the application cycle for an ASGI lifespan connection. app - An asynchronous callable that conforms to version 3.0 of the ASGI specification. This will usually be an ASGI framework application instance. lifespan - A string to configure lifespan support. Choices are auto , on , and off . Default is auto . state - An enumerated LifespanCycleState type that indicates the state of the ASGI connection. exception - An exception raised while handling the ASGI event. app_queue - An asyncio queue (FIFO) containing messages to be received by the application. startup_event - An asyncio event object used to control the application startup flow. shutdown_event - An asyncio event object used to control the application shutdown flow. exception - An exception raised while handling the ASGI event. This may or may not be raised depending on the state. run ( self ) Calls the application with the lifespan connection scope. receive ( self ) Awaited by the application to receive ASGI lifespan events. send ( self , message ) Awaited by the application to send ASGI lifespan events. startup ( self ) Pushes the lifespan startup event to application queue and handles errors. shutdown ( self ) Pushes the lifespan shutdown event to application queue and handles errors.","title":"LifespanCycle"},{"location":"lifespan/#context-manager","text":"Unlike the HTTPCycle and WebSocketCycle classes, the LifespanCycle is also used as a context manager in the adapter class. If lifespan support is turned off, then the application never enters the lifespan cycle context. with ExitStack () as stack : # Ignore lifespan events entirely if the `lifespan` setting is `off`. if self . lifespan in ( \"auto\" , \"on\" ): asgi_cycle : typing . ContextManager = LifespanCycle ( self . app , self . lifespan ) stack . enter_context ( asgi_cycle ) The magic methods __enter__ and __exit__ handle running the async tasks that perform startup and shutdown functions. def __enter__ ( self ) -> None : \"\"\" Runs the event loop for application startup. \"\"\" self . loop . create_task ( self . run ()) self . loop . run_until_complete ( self . startup ()) def __exit__ ( self , exc_type : typing . Optional [ typing . Type [ BaseException ]], exc_value : typing . Optional [ BaseException ], traceback : typing . Optional [ types . TracebackType ], ) -> None : \"\"\" Runs the event loop for application shutdown. \"\"\" self . loop . run_until_complete ( self . shutdown ())","title":"Context manager"},{"location":"lifespan/#lifespancyclestate","text":"class mangum.protocols.lifespan. LifespanCycleState ( value , names=None , * , module=None , qualname=None , type=None , start=1 ) The state of the ASGI lifespan connection. CONNECTING - Initial state. The ASGI application instance will be run with the connection scope containing the lifespan type. STARTUP - The lifespan startup event has been pushed to the queue to be received by the application. SHUTDOWN - The lifespan shutdown event has been pushed to the queue to be received by the application. FAILED - A lifespan failure has been detected, and the connection will be closed with an error. UNSUPPORTED - An application attempted to send a message before receiving the lifepan startup event. If the lifespan argument is \"on\", then the connection will be closed with an error.","title":"LifespanCycleState"},{"location":"release-notes/","text":"0.10.0 Remove WebSocket support to focus on HTTP #127 . Support multiValue headers in response #129 . Thanks @koxudaxi ! Fix duplicate test names #134 . Thanks @a-feld ! Run tests and release package using GitHub Actions #131 . Thanks @simonw ! Only prefix a slash on the api_gateway_base_path if needed #138 . Thanks @dspatoulas ! Add support to Brotli compress #139 . Thanks @fullonic ! 0.9.2 Make boto3 dependency optional #115 0.9.1 Improve documentation, include CHANGELOG in repo, and include release notes in documentation #111 Bugfix lifespan startup behaviour and refactor lifespan cycle, deprecate enable_lifespan parameter, document protocols. #108 0.9.0 Improve documentation #48 Resolve issue with rawQueryString in HTTP APIs using wrong type #105 Implement new WebSocket storage backends for managing connections (PostgreSQL, Redis, DyanmoDB, S3, SQlite) using a single dsn configuration parameter #103 pre-0.9.0 I did not maintain a CHANGELOG prior to 0.9.0, however, I still would like to include a thank you to following people: @lsorber @SKalt @koxudaxi @zachmullen @remorses @allan-simon @jaehyeon-kim Your contributions to previous releases have greatly improved this project and are very much appreciated. Special thanks to @tomchristie for all of his support, encouragement, and guidance early on, and @rajeev for inspiring this project.","title":"Release Notes"},{"location":"release-notes/#0100","text":"Remove WebSocket support to focus on HTTP #127 . Support multiValue headers in response #129 . Thanks @koxudaxi ! Fix duplicate test names #134 . Thanks @a-feld ! Run tests and release package using GitHub Actions #131 . Thanks @simonw ! Only prefix a slash on the api_gateway_base_path if needed #138 . Thanks @dspatoulas ! Add support to Brotli compress #139 . Thanks @fullonic !","title":"0.10.0"},{"location":"release-notes/#092","text":"Make boto3 dependency optional #115","title":"0.9.2"},{"location":"release-notes/#091","text":"Improve documentation, include CHANGELOG in repo, and include release notes in documentation #111 Bugfix lifespan startup behaviour and refactor lifespan cycle, deprecate enable_lifespan parameter, document protocols. #108","title":"0.9.1"},{"location":"release-notes/#090","text":"Improve documentation #48 Resolve issue with rawQueryString in HTTP APIs using wrong type #105 Implement new WebSocket storage backends for managing connections (PostgreSQL, Redis, DyanmoDB, S3, SQlite) using a single dsn configuration parameter #103","title":"0.9.0"},{"location":"release-notes/#pre-090","text":"I did not maintain a CHANGELOG prior to 0.9.0, however, I still would like to include a thank you to following people: @lsorber @SKalt @koxudaxi @zachmullen @remorses @allan-simon @jaehyeon-kim Your contributions to previous releases have greatly improved this project and are very much appreciated. Special thanks to @tomchristie for all of his support, encouragement, and guidance early on, and @rajeev for inspiring this project.","title":"pre-0.9.0"}]}